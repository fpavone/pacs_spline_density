% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/splineDensity.smoothingSplinesValidation.R
\name{smoothSplinesVal}
\alias{smoothSplinesVal}
\title{Estimate density from histogram - for different \code{alpha}}
\usage{
smoothSplinesVal(k, l, alpha, data, xcp, knots, prior = "default",
  cores = 1)
}
\arguments{
\item{k}{smoothing splines degree}

\item{l}{order of derivative in the penalization term}

\item{alpha}{vector of weights for penalization}

\item{data}{an object of class "matrix" containing data to be smoothed, row by row}

\item{xcp}{vector of control points}

\item{knots}{either vector of knots for the splines or a integer for the number of equispaced knots}

\item{prior}{prior used for zero-replacements. This must be one of "perks", "jeffreys", "bayes_laplace", "sq" or "default"}

\item{cores}{number of cores for parallel execution}
}
\value{
A list of three objects:
\item{\code{alpha}}{the values of \code{alpha}}
\item{\code{J}}{the values of the functional evaluated in the minimizing}
\item{\code{CV-error}}{the values of the leave-one-out CV-error}
}
\description{
As \code{\link{smoothSplines}}, \code{smoothSplinesVal} computes the density function that 'best' fits
discretized distributional data, using B-spline basis functions, for different \code{alpha}. \cr
Comparing and choosing an appropriate \code{alpha} is the ultimate goal.
}
\details{
See \code{\link{smoothSplines}} for the description of the algorithm.
}
\examples{
axcp <- c(0.063,0.125,0.25,0.5,1,2,4,8,16,31.5,63,100)
u <- log(0.001)
v <- log(200)
classes <- c(u,log(axcp))
midx <- (classes[-1] + classes[-13])/2
lenx <- (classes[-1] - classes[-13])/2
midy <- adata/lenx
aknots <- seq(midx[1],midx[12], length = 7)
sol <- smoothSplinesVal(k=3,l=2,alpha=10^seq(-4,4,by=1),midy/100,midx,aknots,cores=1)
}
\references{
J. Machalova, K. Hron & G.S. Monti (2016): 
Preprocessing of centred logratio transformed density functions 
using smoothing splines. Journal of Applied Statistics, 43:8, 1419-1435.
}
